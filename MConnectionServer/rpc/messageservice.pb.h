// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messageservice.proto

#ifndef PROTOBUF_messageservice_2eproto__INCLUDED
#define PROTOBUF_messageservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
namespace google {
namespace protobuf {
class Any;
class AnyDefaultTypeInternal;
extern AnyDefaultTypeInternal _Any_default_instance_;
}  // namespace protobuf
}  // namespace google
namespace realtime {
namespace messageservice {
class AuthenticateMessage;
class AuthenticateMessageDefaultTypeInternal;
extern AuthenticateMessageDefaultTypeInternal _AuthenticateMessage_default_instance_;
class AuthenticateReply;
class AuthenticateReplyDefaultTypeInternal;
extern AuthenticateReplyDefaultTypeInternal _AuthenticateReply_default_instance_;
class BaseMessage;
class BaseMessageDefaultTypeInternal;
extern BaseMessageDefaultTypeInternal _BaseMessage_default_instance_;
class C2SMessage;
class C2SMessageDefaultTypeInternal;
extern C2SMessageDefaultTypeInternal _C2SMessage_default_instance_;
class LoginReply;
class LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class PhotoMessage;
class PhotoMessageDefaultTypeInternal;
extern PhotoMessageDefaultTypeInternal _PhotoMessage_default_instance_;
class S2CMessage;
class S2CMessageDefaultTypeInternal;
extern S2CMessageDefaultTypeInternal _S2CMessage_default_instance_;
class TextMessage;
class TextMessageDefaultTypeInternal;
extern TextMessageDefaultTypeInternal _TextMessage_default_instance_;
}  // namespace messageservice
}  // namespace realtime

namespace realtime {
namespace messageservice {

namespace protobuf_messageservice_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_messageservice_2eproto

enum LoginRequest_LoginType {
  LoginRequest_LoginType_EUnknown = 0,
  LoginRequest_LoginType_EUnamePass = 1,
  LoginRequest_LoginType_EFacebookLogin = 2,
  LoginRequest_LoginType_EGoogleLogin = 3,
  LoginRequest_LoginType_EOpenIDLogin = 4,
  LoginRequest_LoginType_EEmailLogin = 5,
  LoginRequest_LoginType_ESmartTokenLogin = 6,
  LoginRequest_LoginType_EPhoneLogin = 7,
  LoginRequest_LoginType_EFBAccKit = 8,
  LoginRequest_LoginType_EOther = 100,
  LoginRequest_LoginType_LoginRequest_LoginType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoginRequest_LoginType_LoginRequest_LoginType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoginRequest_LoginType_IsValid(int value);
const LoginRequest_LoginType LoginRequest_LoginType_LoginType_MIN = LoginRequest_LoginType_EUnknown;
const LoginRequest_LoginType LoginRequest_LoginType_LoginType_MAX = LoginRequest_LoginType_EOther;
const int LoginRequest_LoginType_LoginType_ARRAYSIZE = LoginRequest_LoginType_LoginType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginRequest_LoginType_descriptor();
inline const ::std::string& LoginRequest_LoginType_Name(LoginRequest_LoginType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginRequest_LoginType_descriptor(), value);
}
inline bool LoginRequest_LoginType_Parse(
    const ::std::string& name, LoginRequest_LoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginRequest_LoginType>(
    LoginRequest_LoginType_descriptor(), name, value);
}
enum LoginReply_LoginCode {
  LoginReply_LoginCode_Success = 0,
  LoginReply_LoginCode_WrongPassword = 1,
  LoginReply_LoginCode_BadToken = 2,
  LoginReply_LoginCode_UnknownError = 3,
  LoginReply_LoginCode_LoginReply_LoginCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoginReply_LoginCode_LoginReply_LoginCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoginReply_LoginCode_IsValid(int value);
const LoginReply_LoginCode LoginReply_LoginCode_LoginCode_MIN = LoginReply_LoginCode_Success;
const LoginReply_LoginCode LoginReply_LoginCode_LoginCode_MAX = LoginReply_LoginCode_UnknownError;
const int LoginReply_LoginCode_LoginCode_ARRAYSIZE = LoginReply_LoginCode_LoginCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginReply_LoginCode_descriptor();
inline const ::std::string& LoginReply_LoginCode_Name(LoginReply_LoginCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginReply_LoginCode_descriptor(), value);
}
inline bool LoginReply_LoginCode_Parse(
    const ::std::string& name, LoginReply_LoginCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginReply_LoginCode>(
    LoginReply_LoginCode_descriptor(), name, value);
}
enum C2SMessage_MessageType {
  C2SMessage_MessageType_EAuthenticate = 0,
  C2SMessage_MessageType_ETextMessage = 1,
  C2SMessage_MessageType_EPhotoMessage = 2,
  C2SMessage_MessageType_EVideoMessage = 3,
  C2SMessage_MessageType_EDataMessage = 4,
  C2SMessage_MessageType_ELinkMessage = 5,
  C2SMessage_MessageType_ECompositeMessage = 6,
  C2SMessage_MessageType_EAnythingMessages = 15,
  C2SMessage_MessageType_C2SMessage_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  C2SMessage_MessageType_C2SMessage_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool C2SMessage_MessageType_IsValid(int value);
const C2SMessage_MessageType C2SMessage_MessageType_MessageType_MIN = C2SMessage_MessageType_EAuthenticate;
const C2SMessage_MessageType C2SMessage_MessageType_MessageType_MAX = C2SMessage_MessageType_EAnythingMessages;
const int C2SMessage_MessageType_MessageType_ARRAYSIZE = C2SMessage_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* C2SMessage_MessageType_descriptor();
inline const ::std::string& C2SMessage_MessageType_Name(C2SMessage_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    C2SMessage_MessageType_descriptor(), value);
}
inline bool C2SMessage_MessageType_Parse(
    const ::std::string& name, C2SMessage_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<C2SMessage_MessageType>(
    C2SMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoginRequest_LoginType LoginType;
  static const LoginType EUnknown =
    LoginRequest_LoginType_EUnknown;
  static const LoginType EUnamePass =
    LoginRequest_LoginType_EUnamePass;
  static const LoginType EFacebookLogin =
    LoginRequest_LoginType_EFacebookLogin;
  static const LoginType EGoogleLogin =
    LoginRequest_LoginType_EGoogleLogin;
  static const LoginType EOpenIDLogin =
    LoginRequest_LoginType_EOpenIDLogin;
  static const LoginType EEmailLogin =
    LoginRequest_LoginType_EEmailLogin;
  static const LoginType ESmartTokenLogin =
    LoginRequest_LoginType_ESmartTokenLogin;
  static const LoginType EPhoneLogin =
    LoginRequest_LoginType_EPhoneLogin;
  static const LoginType EFBAccKit =
    LoginRequest_LoginType_EFBAccKit;
  static const LoginType EOther =
    LoginRequest_LoginType_EOther;
  static inline bool LoginType_IsValid(int value) {
    return LoginRequest_LoginType_IsValid(value);
  }
  static const LoginType LoginType_MIN =
    LoginRequest_LoginType_LoginType_MIN;
  static const LoginType LoginType_MAX =
    LoginRequest_LoginType_LoginType_MAX;
  static const int LoginType_ARRAYSIZE =
    LoginRequest_LoginType_LoginType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoginType_descriptor() {
    return LoginRequest_LoginType_descriptor();
  }
  static inline const ::std::string& LoginType_Name(LoginType value) {
    return LoginRequest_LoginType_Name(value);
  }
  static inline bool LoginType_Parse(const ::std::string& name,
      LoginType* value) {
    return LoginRequest_LoginType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string uname = 2;
  void clear_uname();
  static const int kUnameFieldNumber = 2;
  const ::std::string& uname() const;
  void set_uname(const ::std::string& value);
  #if LANG_CXX11
  void set_uname(::std::string&& value);
  #endif
  void set_uname(const char* value);
  void set_uname(const char* value, size_t size);
  ::std::string* mutable_uname();
  ::std::string* release_uname();
  void set_allocated_uname(::std::string* uname);

  // string mobile = 3;
  void clear_mobile();
  static const int kMobileFieldNumber = 3;
  const ::std::string& mobile() const;
  void set_mobile(const ::std::string& value);
  #if LANG_CXX11
  void set_mobile(::std::string&& value);
  #endif
  void set_mobile(const char* value);
  void set_mobile(const char* value, size_t size);
  ::std::string* mutable_mobile();
  ::std::string* release_mobile();
  void set_allocated_mobile(::std::string* mobile);

  // string passw = 4;
  void clear_passw();
  static const int kPasswFieldNumber = 4;
  const ::std::string& passw() const;
  void set_passw(const ::std::string& value);
  #if LANG_CXX11
  void set_passw(::std::string&& value);
  #endif
  void set_passw(const char* value);
  void set_passw(const char* value, size_t size);
  ::std::string* mutable_passw();
  ::std::string* release_passw();
  void set_allocated_passw(::std::string* passw);

  // string email = 5;
  void clear_email();
  static const int kEmailFieldNumber = 5;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string token = 6;
  void clear_token();
  static const int kTokenFieldNumber = 6;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // string appID = 7;
  void clear_appid();
  static const int kAppIDFieldNumber = 7;
  const ::std::string& appid() const;
  void set_appid(const ::std::string& value);
  #if LANG_CXX11
  void set_appid(::std::string&& value);
  #endif
  void set_appid(const char* value);
  void set_appid(const char* value, size_t size);
  ::std::string* mutable_appid();
  ::std::string* release_appid();
  void set_allocated_appid(::std::string* appid);

  // string appPublicKey = 8;
  void clear_apppublickey();
  static const int kAppPublicKeyFieldNumber = 8;
  const ::std::string& apppublickey() const;
  void set_apppublickey(const ::std::string& value);
  #if LANG_CXX11
  void set_apppublickey(::std::string&& value);
  #endif
  void set_apppublickey(const char* value);
  void set_apppublickey(const char* value, size_t size);
  ::std::string* mutable_apppublickey();
  ::std::string* release_apppublickey();
  void set_allocated_apppublickey(::std::string* apppublickey);

  // string signedToken = 9;
  void clear_signedtoken();
  static const int kSignedTokenFieldNumber = 9;
  const ::std::string& signedtoken() const;
  void set_signedtoken(const ::std::string& value);
  #if LANG_CXX11
  void set_signedtoken(::std::string&& value);
  #endif
  void set_signedtoken(const char* value);
  void set_signedtoken(const char* value, size_t size);
  ::std::string* mutable_signedtoken();
  ::std::string* release_signedtoken();
  void set_allocated_signedtoken(::std::string* signedtoken);

  // string data = 20;
  void clear_data();
  static const int kDataFieldNumber = 20;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string otherData = 21;
  void clear_otherdata();
  static const int kOtherDataFieldNumber = 21;
  const ::std::string& otherdata() const;
  void set_otherdata(const ::std::string& value);
  #if LANG_CXX11
  void set_otherdata(::std::string&& value);
  #endif
  void set_otherdata(const char* value);
  void set_otherdata(const char* value, size_t size);
  ::std::string* mutable_otherdata();
  ::std::string* release_otherdata();
  void set_allocated_otherdata(::std::string* otherdata);

  // .realtime.messageservice.LoginRequest.LoginType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::realtime::messageservice::LoginRequest_LoginType type() const;
  void set_type(::realtime::messageservice::LoginRequest_LoginType value);

  // @@protoc_insertion_point(class_scope:realtime.messageservice.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uname_;
  ::google::protobuf::internal::ArenaStringPtr mobile_;
  ::google::protobuf::internal::ArenaStringPtr passw_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr appid_;
  ::google::protobuf::internal::ArenaStringPtr apppublickey_;
  ::google::protobuf::internal::ArenaStringPtr signedtoken_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr otherdata_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.LoginReply) */ {
 public:
  LoginReply();
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReply& default_instance();

  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LoginReply* other);

  // implements Message ----------------------------------------------

  inline LoginReply* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoginReply_LoginCode LoginCode;
  static const LoginCode Success =
    LoginReply_LoginCode_Success;
  static const LoginCode WrongPassword =
    LoginReply_LoginCode_WrongPassword;
  static const LoginCode BadToken =
    LoginReply_LoginCode_BadToken;
  static const LoginCode UnknownError =
    LoginReply_LoginCode_UnknownError;
  static inline bool LoginCode_IsValid(int value) {
    return LoginReply_LoginCode_IsValid(value);
  }
  static const LoginCode LoginCode_MIN =
    LoginReply_LoginCode_LoginCode_MIN;
  static const LoginCode LoginCode_MAX =
    LoginReply_LoginCode_LoginCode_MAX;
  static const int LoginCode_ARRAYSIZE =
    LoginReply_LoginCode_LoginCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoginCode_descriptor() {
    return LoginReply_LoginCode_descriptor();
  }
  static inline const ::std::string& LoginCode_Name(LoginCode value) {
    return LoginReply_LoginCode_Name(value);
  }
  static inline bool LoginCode_Parse(const ::std::string& name,
      LoginCode* value) {
    return LoginReply_LoginCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string detail = 2;
  void clear_detail();
  static const int kDetailFieldNumber = 2;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // string sessionKey = 3;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 3;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const char* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // .realtime.messageservice.LoginReply.LoginCode errorCode = 1;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::realtime::messageservice::LoginReply_LoginCode errorcode() const;
  void set_errorcode(::realtime::messageservice::LoginReply_LoginCode value);

  // @@protoc_insertion_point(class_scope:realtime.messageservice.LoginReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  int errorcode_;
  mutable int _cached_size_;
  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.AuthenticateMessage) */ {
 public:
  AuthenticateMessage();
  virtual ~AuthenticateMessage();

  AuthenticateMessage(const AuthenticateMessage& from);

  inline AuthenticateMessage& operator=(const AuthenticateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateMessage& default_instance();

  static inline const AuthenticateMessage* internal_default_instance() {
    return reinterpret_cast<const AuthenticateMessage*>(
               &_AuthenticateMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AuthenticateMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthenticateMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthenticateMessage& from);
  void MergeFrom(const AuthenticateMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthenticateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sessionKey = 1;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 1;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const char* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // uint64 userID = 2;
  void clear_userid();
  static const int kUserIDFieldNumber = 2;
  ::google::protobuf::uint64 userid() const;
  void set_userid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:realtime.messageservice.AuthenticateMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  ::google::protobuf::uint64 userid_;
  mutable int _cached_size_;
  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.AuthenticateReply) */ {
 public:
  AuthenticateReply();
  virtual ~AuthenticateReply();

  AuthenticateReply(const AuthenticateReply& from);

  inline AuthenticateReply& operator=(const AuthenticateReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateReply& default_instance();

  static inline const AuthenticateReply* internal_default_instance() {
    return reinterpret_cast<const AuthenticateReply*>(
               &_AuthenticateReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AuthenticateReply* other);

  // implements Message ----------------------------------------------

  inline AuthenticateReply* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthenticateReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthenticateReply& from);
  void MergeFrom(const AuthenticateReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthenticateReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sessionKey = 2;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 2;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const char* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // uint64 userID = 3;
  void clear_userid();
  static const int kUserIDFieldNumber = 3;
  ::google::protobuf::uint64 userid() const;
  void set_userid(::google::protobuf::uint64 value);

  // bool authenticated = 1;
  void clear_authenticated();
  static const int kAuthenticatedFieldNumber = 1;
  bool authenticated() const;
  void set_authenticated(bool value);

  // @@protoc_insertion_point(class_scope:realtime.messageservice.AuthenticateReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  ::google::protobuf::uint64 userid_;
  bool authenticated_;
  mutable int _cached_size_;
  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.BaseMessage) */ {
 public:
  BaseMessage();
  virtual ~BaseMessage();

  BaseMessage(const BaseMessage& from);

  inline BaseMessage& operator=(const BaseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseMessage& default_instance();

  enum TargetCase {
    kChannelID = 1,
    kUserID = 2,
    kTopic = 3,
    TARGET_NOT_SET = 0,
  };

  static inline const BaseMessage* internal_default_instance() {
    return reinterpret_cast<const BaseMessage*>(
               &_BaseMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BaseMessage* other);

  // implements Message ----------------------------------------------

  inline BaseMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  BaseMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BaseMessage& from);
  void MergeFrom(const BaseMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BaseMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 fromUID = 8;
  void clear_fromuid();
  static const int kFromUIDFieldNumber = 8;
  ::google::protobuf::uint64 fromuid() const;
  void set_fromuid(::google::protobuf::uint64 value);

  // uint64 channelID = 1;
  private:
  bool has_channelid() const;
  public:
  void clear_channelid();
  static const int kChannelIDFieldNumber = 1;
  ::google::protobuf::uint64 channelid() const;
  void set_channelid(::google::protobuf::uint64 value);

  // uint64 userID = 2;
  private:
  bool has_userid() const;
  public:
  void clear_userid();
  static const int kUserIDFieldNumber = 2;
  ::google::protobuf::uint64 userid() const;
  void set_userid(::google::protobuf::uint64 value);

  // string topic = 3;
  private:
  bool has_topic() const;
  public:
  void clear_topic();
  static const int kTopicFieldNumber = 3;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  TargetCase Target_case() const;
  // @@protoc_insertion_point(class_scope:realtime.messageservice.BaseMessage)
 private:
  void set_has_channelid();
  void set_has_userid();
  void set_has_topic();

  inline bool has_Target() const;
  void clear_Target();
  inline void clear_has_Target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 fromuid_;
  union TargetUnion {
    TargetUnion() {}
    ::google::protobuf::uint64 channelid_;
    ::google::protobuf::uint64 userid_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
  } Target_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.TextMessage) */ {
 public:
  TextMessage();
  virtual ~TextMessage();

  TextMessage(const TextMessage& from);

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMessage& default_instance();

  static inline const TextMessage* internal_default_instance() {
    return reinterpret_cast<const TextMessage*>(
               &_TextMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TextMessage* other);

  // implements Message ----------------------------------------------

  inline TextMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  TextMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TextMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:realtime.messageservice.TextMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable int _cached_size_;
  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhotoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.PhotoMessage) */ {
 public:
  PhotoMessage();
  virtual ~PhotoMessage();

  PhotoMessage(const PhotoMessage& from);

  inline PhotoMessage& operator=(const PhotoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhotoMessage& default_instance();

  static inline const PhotoMessage* internal_default_instance() {
    return reinterpret_cast<const PhotoMessage*>(
               &_PhotoMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PhotoMessage* other);

  // implements Message ----------------------------------------------

  inline PhotoMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  PhotoMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PhotoMessage& from);
  void MergeFrom(const PhotoMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PhotoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string photoFormat = 2;
  void clear_photoformat();
  static const int kPhotoFormatFieldNumber = 2;
  const ::std::string& photoformat() const;
  void set_photoformat(const ::std::string& value);
  #if LANG_CXX11
  void set_photoformat(::std::string&& value);
  #endif
  void set_photoformat(const char* value);
  void set_photoformat(const char* value, size_t size);
  ::std::string* mutable_photoformat();
  ::std::string* release_photoformat();
  void set_allocated_photoformat(::std::string* photoformat);

  // string photoData = 3;
  void clear_photodata();
  static const int kPhotoDataFieldNumber = 3;
  const ::std::string& photodata() const;
  void set_photodata(const ::std::string& value);
  #if LANG_CXX11
  void set_photodata(::std::string&& value);
  #endif
  void set_photodata(const char* value);
  void set_photodata(const char* value, size_t size);
  ::std::string* mutable_photodata();
  ::std::string* release_photodata();
  void set_allocated_photodata(::std::string* photodata);

  // string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string metaData = 5;
  void clear_metadata();
  static const int kMetaDataFieldNumber = 5;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:realtime.messageservice.PhotoMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr photoformat_;
  ::google::protobuf::internal::ArenaStringPtr photodata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  mutable int _cached_size_;
  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class C2SMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.C2SMessage) */ {
 public:
  C2SMessage();
  virtual ~C2SMessage();

  C2SMessage(const C2SMessage& from);

  inline C2SMessage& operator=(const C2SMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SMessage& default_instance();

  enum MessagesCase {
    kAuthMessage = 4,
    kTxt = 5,
    kPhotoMsg = 6,
    MESSAGES_NOT_SET = 0,
  };

  static inline const C2SMessage* internal_default_instance() {
    return reinterpret_cast<const C2SMessage*>(
               &_C2SMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(C2SMessage* other);

  // implements Message ----------------------------------------------

  inline C2SMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  C2SMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const C2SMessage& from);
  void MergeFrom(const C2SMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(C2SMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef C2SMessage_MessageType MessageType;
  static const MessageType EAuthenticate =
    C2SMessage_MessageType_EAuthenticate;
  static const MessageType ETextMessage =
    C2SMessage_MessageType_ETextMessage;
  static const MessageType EPhotoMessage =
    C2SMessage_MessageType_EPhotoMessage;
  static const MessageType EVideoMessage =
    C2SMessage_MessageType_EVideoMessage;
  static const MessageType EDataMessage =
    C2SMessage_MessageType_EDataMessage;
  static const MessageType ELinkMessage =
    C2SMessage_MessageType_ELinkMessage;
  static const MessageType ECompositeMessage =
    C2SMessage_MessageType_ECompositeMessage;
  static const MessageType EAnythingMessages =
    C2SMessage_MessageType_EAnythingMessages;
  static inline bool MessageType_IsValid(int value) {
    return C2SMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    C2SMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    C2SMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    C2SMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return C2SMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return C2SMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return C2SMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .realtime.messageservice.BaseMessage base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  const ::realtime::messageservice::BaseMessage& base() const;
  ::realtime::messageservice::BaseMessage* mutable_base();
  ::realtime::messageservice::BaseMessage* release_base();
  void set_allocated_base(::realtime::messageservice::BaseMessage* base);

  // int64 nonceID = 3;
  void clear_nonceid();
  static const int kNonceIDFieldNumber = 3;
  ::google::protobuf::int64 nonceid() const;
  void set_nonceid(::google::protobuf::int64 value);

  // .realtime.messageservice.C2SMessage.MessageType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::realtime::messageservice::C2SMessage_MessageType type() const;
  void set_type(::realtime::messageservice::C2SMessage_MessageType value);

  // .realtime.messageservice.AuthenticateMessage authMessage = 4;
  bool has_authmessage() const;
  void clear_authmessage();
  static const int kAuthMessageFieldNumber = 4;
  const ::realtime::messageservice::AuthenticateMessage& authmessage() const;
  ::realtime::messageservice::AuthenticateMessage* mutable_authmessage();
  ::realtime::messageservice::AuthenticateMessage* release_authmessage();
  void set_allocated_authmessage(::realtime::messageservice::AuthenticateMessage* authmessage);

  // .realtime.messageservice.TextMessage txt = 5;
  bool has_txt() const;
  void clear_txt();
  static const int kTxtFieldNumber = 5;
  const ::realtime::messageservice::TextMessage& txt() const;
  ::realtime::messageservice::TextMessage* mutable_txt();
  ::realtime::messageservice::TextMessage* release_txt();
  void set_allocated_txt(::realtime::messageservice::TextMessage* txt);

  // .realtime.messageservice.PhotoMessage photoMsg = 6;
  bool has_photomsg() const;
  void clear_photomsg();
  static const int kPhotoMsgFieldNumber = 6;
  const ::realtime::messageservice::PhotoMessage& photomsg() const;
  ::realtime::messageservice::PhotoMessage* mutable_photomsg();
  ::realtime::messageservice::PhotoMessage* release_photomsg();
  void set_allocated_photomsg(::realtime::messageservice::PhotoMessage* photomsg);

  MessagesCase messages_case() const;
  // @@protoc_insertion_point(class_scope:realtime.messageservice.C2SMessage)
 private:
  void set_has_authmessage();
  void set_has_txt();
  void set_has_photomsg();

  inline bool has_messages() const;
  void clear_messages();
  inline void clear_has_messages();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::realtime::messageservice::BaseMessage* base_;
  ::google::protobuf::int64 nonceid_;
  int type_;
  union MessagesUnion {
    MessagesUnion() {}
    ::realtime::messageservice::AuthenticateMessage* authmessage_;
    ::realtime::messageservice::TextMessage* txt_;
    ::realtime::messageservice::PhotoMessage* photomsg_;
  } messages_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class S2CMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:realtime.messageservice.S2CMessage) */ {
 public:
  S2CMessage();
  virtual ~S2CMessage();

  S2CMessage(const S2CMessage& from);

  inline S2CMessage& operator=(const S2CMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CMessage& default_instance();

  enum MessagesCase {
    kAuthReply = 5,
    kTxt = 6,
    kPhotoMsg = 7,
    MESSAGES_NOT_SET = 0,
  };

  static inline const S2CMessage* internal_default_instance() {
    return reinterpret_cast<const S2CMessage*>(
               &_S2CMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(S2CMessage* other);

  // implements Message ----------------------------------------------

  inline S2CMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  S2CMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const S2CMessage& from);
  void MergeFrom(const S2CMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(S2CMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string commonMessage = 1;
  void clear_commonmessage();
  static const int kCommonMessageFieldNumber = 1;
  const ::std::string& commonmessage() const;
  void set_commonmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_commonmessage(::std::string&& value);
  #endif
  void set_commonmessage(const char* value);
  void set_commonmessage(const char* value, size_t size);
  ::std::string* mutable_commonmessage();
  ::std::string* release_commonmessage();
  void set_allocated_commonmessage(::std::string* commonmessage);

  // .realtime.messageservice.BaseMessage base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  const ::realtime::messageservice::BaseMessage& base() const;
  ::realtime::messageservice::BaseMessage* mutable_base();
  ::realtime::messageservice::BaseMessage* release_base();
  void set_allocated_base(::realtime::messageservice::BaseMessage* base);

  // .google.protobuf.Any anything = 20;
  bool has_anything() const;
  void clear_anything();
  static const int kAnythingFieldNumber = 20;
  const ::google::protobuf::Any& anything() const;
  ::google::protobuf::Any* mutable_anything();
  ::google::protobuf::Any* release_anything();
  void set_allocated_anything(::google::protobuf::Any* anything);

  // uint64 msgID = 3;
  void clear_msgid();
  static const int kMsgIDFieldNumber = 3;
  ::google::protobuf::uint64 msgid() const;
  void set_msgid(::google::protobuf::uint64 value);

  // .realtime.messageservice.AuthenticateReply authReply = 5;
  bool has_authreply() const;
  void clear_authreply();
  static const int kAuthReplyFieldNumber = 5;
  const ::realtime::messageservice::AuthenticateReply& authreply() const;
  ::realtime::messageservice::AuthenticateReply* mutable_authreply();
  ::realtime::messageservice::AuthenticateReply* release_authreply();
  void set_allocated_authreply(::realtime::messageservice::AuthenticateReply* authreply);

  // .realtime.messageservice.TextMessage txt = 6;
  bool has_txt() const;
  void clear_txt();
  static const int kTxtFieldNumber = 6;
  const ::realtime::messageservice::TextMessage& txt() const;
  ::realtime::messageservice::TextMessage* mutable_txt();
  ::realtime::messageservice::TextMessage* release_txt();
  void set_allocated_txt(::realtime::messageservice::TextMessage* txt);

  // .realtime.messageservice.PhotoMessage photoMsg = 7;
  bool has_photomsg() const;
  void clear_photomsg();
  static const int kPhotoMsgFieldNumber = 7;
  const ::realtime::messageservice::PhotoMessage& photomsg() const;
  ::realtime::messageservice::PhotoMessage* mutable_photomsg();
  ::realtime::messageservice::PhotoMessage* release_photomsg();
  void set_allocated_photomsg(::realtime::messageservice::PhotoMessage* photomsg);

  MessagesCase Messages_case() const;
  // @@protoc_insertion_point(class_scope:realtime.messageservice.S2CMessage)
 private:
  void set_has_authreply();
  void set_has_txt();
  void set_has_photomsg();

  inline bool has_Messages() const;
  void clear_Messages();
  inline void clear_has_Messages();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr commonmessage_;
  ::realtime::messageservice::BaseMessage* base_;
  ::google::protobuf::Any* anything_;
  ::google::protobuf::uint64 msgid_;
  union MessagesUnion {
    MessagesUnion() {}
    ::realtime::messageservice::AuthenticateReply* authreply_;
    ::realtime::messageservice::TextMessage* txt_;
    ::realtime::messageservice::PhotoMessage* photomsg_;
  } Messages_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_messageservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LoginRequest

// .realtime.messageservice.LoginRequest.LoginType type = 1;
inline void LoginRequest::clear_type() {
  type_ = 0;
}
inline ::realtime::messageservice::LoginRequest_LoginType LoginRequest::type() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.type)
  return static_cast< ::realtime::messageservice::LoginRequest_LoginType >(type_);
}
inline void LoginRequest::set_type(::realtime::messageservice::LoginRequest_LoginType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.type)
}

// string uname = 2;
inline void LoginRequest::clear_uname() {
  uname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::uname() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.uname)
  return uname_.GetNoArena();
}
inline void LoginRequest::set_uname(const ::std::string& value) {
  
  uname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.uname)
}
#if LANG_CXX11
inline void LoginRequest::set_uname(::std::string&& value) {
  
  uname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.uname)
}
#endif
inline void LoginRequest::set_uname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.uname)
}
inline void LoginRequest::set_uname(const char* value, size_t size) {
  
  uname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.uname)
}
inline ::std::string* LoginRequest::mutable_uname() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.uname)
  return uname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_uname() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.uname)
  
  return uname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_uname(::std::string* uname) {
  if (uname != NULL) {
    
  } else {
    
  }
  uname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uname);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.uname)
}

// string mobile = 3;
inline void LoginRequest::clear_mobile() {
  mobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::mobile() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.mobile)
  return mobile_.GetNoArena();
}
inline void LoginRequest::set_mobile(const ::std::string& value) {
  
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.mobile)
}
#if LANG_CXX11
inline void LoginRequest::set_mobile(::std::string&& value) {
  
  mobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.mobile)
}
#endif
inline void LoginRequest::set_mobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.mobile)
}
inline void LoginRequest::set_mobile(const char* value, size_t size) {
  
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.mobile)
}
inline ::std::string* LoginRequest::mutable_mobile() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.mobile)
  return mobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_mobile() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.mobile)
  
  return mobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile != NULL) {
    
  } else {
    
  }
  mobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.mobile)
}

// string passw = 4;
inline void LoginRequest::clear_passw() {
  passw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::passw() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.passw)
  return passw_.GetNoArena();
}
inline void LoginRequest::set_passw(const ::std::string& value) {
  
  passw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.passw)
}
#if LANG_CXX11
inline void LoginRequest::set_passw(::std::string&& value) {
  
  passw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.passw)
}
#endif
inline void LoginRequest::set_passw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.passw)
}
inline void LoginRequest::set_passw(const char* value, size_t size) {
  
  passw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.passw)
}
inline ::std::string* LoginRequest::mutable_passw() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.passw)
  return passw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_passw() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.passw)
  
  return passw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_passw(::std::string* passw) {
  if (passw != NULL) {
    
  } else {
    
  }
  passw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passw);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.passw)
}

// string email = 5;
inline void LoginRequest::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::email() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.email)
  return email_.GetNoArena();
}
inline void LoginRequest::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.email)
}
#if LANG_CXX11
inline void LoginRequest::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.email)
}
#endif
inline void LoginRequest::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.email)
}
inline void LoginRequest::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.email)
}
inline ::std::string* LoginRequest::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_email() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.email)
}

// string token = 6;
inline void LoginRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::token() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.token)
  return token_.GetNoArena();
}
inline void LoginRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.token)
}
#if LANG_CXX11
inline void LoginRequest::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.token)
}
#endif
inline void LoginRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.token)
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.token)
}
inline ::std::string* LoginRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_token() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.token)
}

// string appID = 7;
inline void LoginRequest::clear_appid() {
  appid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::appid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.appID)
  return appid_.GetNoArena();
}
inline void LoginRequest::set_appid(const ::std::string& value) {
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.appID)
}
#if LANG_CXX11
inline void LoginRequest::set_appid(::std::string&& value) {
  
  appid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.appID)
}
#endif
inline void LoginRequest::set_appid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.appID)
}
inline void LoginRequest::set_appid(const char* value, size_t size) {
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.appID)
}
inline ::std::string* LoginRequest::mutable_appid() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.appID)
  return appid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_appid() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.appID)
  
  return appid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_appid(::std::string* appid) {
  if (appid != NULL) {
    
  } else {
    
  }
  appid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), appid);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.appID)
}

// string appPublicKey = 8;
inline void LoginRequest::clear_apppublickey() {
  apppublickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::apppublickey() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.appPublicKey)
  return apppublickey_.GetNoArena();
}
inline void LoginRequest::set_apppublickey(const ::std::string& value) {
  
  apppublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.appPublicKey)
}
#if LANG_CXX11
inline void LoginRequest::set_apppublickey(::std::string&& value) {
  
  apppublickey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.appPublicKey)
}
#endif
inline void LoginRequest::set_apppublickey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  apppublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.appPublicKey)
}
inline void LoginRequest::set_apppublickey(const char* value, size_t size) {
  
  apppublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.appPublicKey)
}
inline ::std::string* LoginRequest::mutable_apppublickey() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.appPublicKey)
  return apppublickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_apppublickey() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.appPublicKey)
  
  return apppublickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_apppublickey(::std::string* apppublickey) {
  if (apppublickey != NULL) {
    
  } else {
    
  }
  apppublickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apppublickey);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.appPublicKey)
}

// string signedToken = 9;
inline void LoginRequest::clear_signedtoken() {
  signedtoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::signedtoken() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.signedToken)
  return signedtoken_.GetNoArena();
}
inline void LoginRequest::set_signedtoken(const ::std::string& value) {
  
  signedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.signedToken)
}
#if LANG_CXX11
inline void LoginRequest::set_signedtoken(::std::string&& value) {
  
  signedtoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.signedToken)
}
#endif
inline void LoginRequest::set_signedtoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.signedToken)
}
inline void LoginRequest::set_signedtoken(const char* value, size_t size) {
  
  signedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.signedToken)
}
inline ::std::string* LoginRequest::mutable_signedtoken() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.signedToken)
  return signedtoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_signedtoken() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.signedToken)
  
  return signedtoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_signedtoken(::std::string* signedtoken) {
  if (signedtoken != NULL) {
    
  } else {
    
  }
  signedtoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signedtoken);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.signedToken)
}

// string data = 20;
inline void LoginRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::data() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.data)
  return data_.GetNoArena();
}
inline void LoginRequest::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.data)
}
#if LANG_CXX11
inline void LoginRequest::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.data)
}
#endif
inline void LoginRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.data)
}
inline void LoginRequest::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.data)
}
inline ::std::string* LoginRequest::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_data() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.data)
}

// string otherData = 21;
inline void LoginRequest::clear_otherdata() {
  otherdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::otherdata() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginRequest.otherData)
  return otherdata_.GetNoArena();
}
inline void LoginRequest::set_otherdata(const ::std::string& value) {
  
  otherdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginRequest.otherData)
}
#if LANG_CXX11
inline void LoginRequest::set_otherdata(::std::string&& value) {
  
  otherdata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginRequest.otherData)
}
#endif
inline void LoginRequest::set_otherdata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  otherdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginRequest.otherData)
}
inline void LoginRequest::set_otherdata(const char* value, size_t size) {
  
  otherdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginRequest.otherData)
}
inline ::std::string* LoginRequest::mutable_otherdata() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginRequest.otherData)
  return otherdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_otherdata() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginRequest.otherData)
  
  return otherdata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_otherdata(::std::string* otherdata) {
  if (otherdata != NULL) {
    
  } else {
    
  }
  otherdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), otherdata);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginRequest.otherData)
}

// -------------------------------------------------------------------

// LoginReply

// .realtime.messageservice.LoginReply.LoginCode errorCode = 1;
inline void LoginReply::clear_errorcode() {
  errorcode_ = 0;
}
inline ::realtime::messageservice::LoginReply_LoginCode LoginReply::errorcode() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginReply.errorCode)
  return static_cast< ::realtime::messageservice::LoginReply_LoginCode >(errorcode_);
}
inline void LoginReply::set_errorcode(::realtime::messageservice::LoginReply_LoginCode value) {
  
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginReply.errorCode)
}

// string detail = 2;
inline void LoginReply::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReply::detail() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginReply.detail)
  return detail_.GetNoArena();
}
inline void LoginReply::set_detail(const ::std::string& value) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginReply.detail)
}
#if LANG_CXX11
inline void LoginReply::set_detail(::std::string&& value) {
  
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginReply.detail)
}
#endif
inline void LoginReply::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginReply.detail)
}
inline void LoginReply::set_detail(const char* value, size_t size) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginReply.detail)
}
inline ::std::string* LoginReply::mutable_detail() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginReply.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReply::release_detail() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginReply.detail)
  
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReply::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    
  } else {
    
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginReply.detail)
}

// string sessionKey = 3;
inline void LoginReply::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReply::sessionkey() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.LoginReply.sessionKey)
  return sessionkey_.GetNoArena();
}
inline void LoginReply::set_sessionkey(const ::std::string& value) {
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.LoginReply.sessionKey)
}
#if LANG_CXX11
inline void LoginReply::set_sessionkey(::std::string&& value) {
  
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.LoginReply.sessionKey)
}
#endif
inline void LoginReply::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.LoginReply.sessionKey)
}
inline void LoginReply::set_sessionkey(const char* value, size_t size) {
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.LoginReply.sessionKey)
}
inline ::std::string* LoginReply::mutable_sessionkey() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.LoginReply.sessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReply::release_sessionkey() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.LoginReply.sessionKey)
  
  return sessionkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReply::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    
  } else {
    
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.LoginReply.sessionKey)
}

// -------------------------------------------------------------------

// AuthenticateMessage

// string sessionKey = 1;
inline void AuthenticateMessage::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateMessage::sessionkey() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.AuthenticateMessage.sessionKey)
  return sessionkey_.GetNoArena();
}
inline void AuthenticateMessage::set_sessionkey(const ::std::string& value) {
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.AuthenticateMessage.sessionKey)
}
#if LANG_CXX11
inline void AuthenticateMessage::set_sessionkey(::std::string&& value) {
  
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.AuthenticateMessage.sessionKey)
}
#endif
inline void AuthenticateMessage::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.AuthenticateMessage.sessionKey)
}
inline void AuthenticateMessage::set_sessionkey(const char* value, size_t size) {
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.AuthenticateMessage.sessionKey)
}
inline ::std::string* AuthenticateMessage::mutable_sessionkey() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.AuthenticateMessage.sessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateMessage::release_sessionkey() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.AuthenticateMessage.sessionKey)
  
  return sessionkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateMessage::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    
  } else {
    
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.AuthenticateMessage.sessionKey)
}

// uint64 userID = 2;
inline void AuthenticateMessage::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AuthenticateMessage::userid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.AuthenticateMessage.userID)
  return userid_;
}
inline void AuthenticateMessage::set_userid(::google::protobuf::uint64 value) {
  
  userid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.AuthenticateMessage.userID)
}

// -------------------------------------------------------------------

// AuthenticateReply

// bool authenticated = 1;
inline void AuthenticateReply::clear_authenticated() {
  authenticated_ = false;
}
inline bool AuthenticateReply::authenticated() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.AuthenticateReply.authenticated)
  return authenticated_;
}
inline void AuthenticateReply::set_authenticated(bool value) {
  
  authenticated_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.AuthenticateReply.authenticated)
}

// string sessionKey = 2;
inline void AuthenticateReply::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateReply::sessionkey() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.AuthenticateReply.sessionKey)
  return sessionkey_.GetNoArena();
}
inline void AuthenticateReply::set_sessionkey(const ::std::string& value) {
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.AuthenticateReply.sessionKey)
}
#if LANG_CXX11
inline void AuthenticateReply::set_sessionkey(::std::string&& value) {
  
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.AuthenticateReply.sessionKey)
}
#endif
inline void AuthenticateReply::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.AuthenticateReply.sessionKey)
}
inline void AuthenticateReply::set_sessionkey(const char* value, size_t size) {
  
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.AuthenticateReply.sessionKey)
}
inline ::std::string* AuthenticateReply::mutable_sessionkey() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.AuthenticateReply.sessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateReply::release_sessionkey() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.AuthenticateReply.sessionKey)
  
  return sessionkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateReply::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    
  } else {
    
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.AuthenticateReply.sessionKey)
}

// uint64 userID = 3;
inline void AuthenticateReply::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AuthenticateReply::userid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.AuthenticateReply.userID)
  return userid_;
}
inline void AuthenticateReply::set_userid(::google::protobuf::uint64 value) {
  
  userid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.AuthenticateReply.userID)
}

// -------------------------------------------------------------------

// BaseMessage

// uint64 channelID = 1;
inline bool BaseMessage::has_channelid() const {
  return Target_case() == kChannelID;
}
inline void BaseMessage::set_has_channelid() {
  _oneof_case_[0] = kChannelID;
}
inline void BaseMessage::clear_channelid() {
  if (has_channelid()) {
    Target_.channelid_ = GOOGLE_ULONGLONG(0);
    clear_has_Target();
  }
}
inline ::google::protobuf::uint64 BaseMessage::channelid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.BaseMessage.channelID)
  if (has_channelid()) {
    return Target_.channelid_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void BaseMessage::set_channelid(::google::protobuf::uint64 value) {
  if (!has_channelid()) {
    clear_Target();
    set_has_channelid();
  }
  Target_.channelid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.BaseMessage.channelID)
}

// uint64 userID = 2;
inline bool BaseMessage::has_userid() const {
  return Target_case() == kUserID;
}
inline void BaseMessage::set_has_userid() {
  _oneof_case_[0] = kUserID;
}
inline void BaseMessage::clear_userid() {
  if (has_userid()) {
    Target_.userid_ = GOOGLE_ULONGLONG(0);
    clear_has_Target();
  }
}
inline ::google::protobuf::uint64 BaseMessage::userid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.BaseMessage.userID)
  if (has_userid()) {
    return Target_.userid_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void BaseMessage::set_userid(::google::protobuf::uint64 value) {
  if (!has_userid()) {
    clear_Target();
    set_has_userid();
  }
  Target_.userid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.BaseMessage.userID)
}

// string topic = 3;
inline bool BaseMessage::has_topic() const {
  return Target_case() == kTopic;
}
inline void BaseMessage::set_has_topic() {
  _oneof_case_[0] = kTopic;
}
inline void BaseMessage::clear_topic() {
  if (has_topic()) {
    Target_.topic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Target();
  }
}
inline const ::std::string& BaseMessage::topic() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.BaseMessage.topic)
  if (has_topic()) {
    return Target_.topic_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void BaseMessage::set_topic(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:realtime.messageservice.BaseMessage.topic)
  if (!has_topic()) {
    clear_Target();
    set_has_topic();
    Target_.topic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Target_.topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.BaseMessage.topic)
}
#if LANG_CXX11
inline void BaseMessage::set_topic(::std::string&& value) {
  // @@protoc_insertion_point(field_set:realtime.messageservice.BaseMessage.topic)
  if (!has_topic()) {
    clear_Target();
    set_has_topic();
    Target_.topic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Target_.topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.BaseMessage.topic)
}
#endif
inline void BaseMessage::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_topic()) {
    clear_Target();
    set_has_topic();
    Target_.topic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Target_.topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.BaseMessage.topic)
}
inline void BaseMessage::set_topic(const char* value, size_t size) {
  if (!has_topic()) {
    clear_Target();
    set_has_topic();
    Target_.topic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Target_.topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.BaseMessage.topic)
}
inline ::std::string* BaseMessage::mutable_topic() {
  if (!has_topic()) {
    clear_Target();
    set_has_topic();
    Target_.topic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.BaseMessage.topic)
  return Target_.topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseMessage::release_topic() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.BaseMessage.topic)
  if (has_topic()) {
    clear_has_Target();
    return Target_.topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void BaseMessage::set_allocated_topic(::std::string* topic) {
  if (!has_topic()) {
    Target_.topic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Target();
  if (topic != NULL) {
    set_has_topic();
    Target_.topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        topic);
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.BaseMessage.topic)
}

// uint64 fromUID = 8;
inline void BaseMessage::clear_fromuid() {
  fromuid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BaseMessage::fromuid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.BaseMessage.fromUID)
  return fromuid_;
}
inline void BaseMessage::set_fromuid(::google::protobuf::uint64 value) {
  
  fromuid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.BaseMessage.fromUID)
}

inline bool BaseMessage::has_Target() const {
  return Target_case() != TARGET_NOT_SET;
}
inline void BaseMessage::clear_has_Target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline BaseMessage::TargetCase BaseMessage::Target_case() const {
  return BaseMessage::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextMessage

// string text = 2;
inline void TextMessage::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextMessage::text() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.TextMessage.text)
  return text_.GetNoArena();
}
inline void TextMessage::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.TextMessage.text)
}
#if LANG_CXX11
inline void TextMessage::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.TextMessage.text)
}
#endif
inline void TextMessage::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.TextMessage.text)
}
inline void TextMessage::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.TextMessage.text)
}
inline ::std::string* TextMessage::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.TextMessage.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextMessage::release_text() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.TextMessage.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.TextMessage.text)
}

// -------------------------------------------------------------------

// PhotoMessage

// string photoFormat = 2;
inline void PhotoMessage::clear_photoformat() {
  photoformat_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PhotoMessage::photoformat() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.PhotoMessage.photoFormat)
  return photoformat_.GetNoArena();
}
inline void PhotoMessage::set_photoformat(const ::std::string& value) {
  
  photoformat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.PhotoMessage.photoFormat)
}
#if LANG_CXX11
inline void PhotoMessage::set_photoformat(::std::string&& value) {
  
  photoformat_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.PhotoMessage.photoFormat)
}
#endif
inline void PhotoMessage::set_photoformat(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  photoformat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.PhotoMessage.photoFormat)
}
inline void PhotoMessage::set_photoformat(const char* value, size_t size) {
  
  photoformat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.PhotoMessage.photoFormat)
}
inline ::std::string* PhotoMessage::mutable_photoformat() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.PhotoMessage.photoFormat)
  return photoformat_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PhotoMessage::release_photoformat() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.PhotoMessage.photoFormat)
  
  return photoformat_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PhotoMessage::set_allocated_photoformat(::std::string* photoformat) {
  if (photoformat != NULL) {
    
  } else {
    
  }
  photoformat_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), photoformat);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.PhotoMessage.photoFormat)
}

// string photoData = 3;
inline void PhotoMessage::clear_photodata() {
  photodata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PhotoMessage::photodata() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.PhotoMessage.photoData)
  return photodata_.GetNoArena();
}
inline void PhotoMessage::set_photodata(const ::std::string& value) {
  
  photodata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.PhotoMessage.photoData)
}
#if LANG_CXX11
inline void PhotoMessage::set_photodata(::std::string&& value) {
  
  photodata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.PhotoMessage.photoData)
}
#endif
inline void PhotoMessage::set_photodata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  photodata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.PhotoMessage.photoData)
}
inline void PhotoMessage::set_photodata(const char* value, size_t size) {
  
  photodata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.PhotoMessage.photoData)
}
inline ::std::string* PhotoMessage::mutable_photodata() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.PhotoMessage.photoData)
  return photodata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PhotoMessage::release_photodata() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.PhotoMessage.photoData)
  
  return photodata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PhotoMessage::set_allocated_photodata(::std::string* photodata) {
  if (photodata != NULL) {
    
  } else {
    
  }
  photodata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), photodata);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.PhotoMessage.photoData)
}

// string description = 4;
inline void PhotoMessage::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PhotoMessage::description() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.PhotoMessage.description)
  return description_.GetNoArena();
}
inline void PhotoMessage::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.PhotoMessage.description)
}
#if LANG_CXX11
inline void PhotoMessage::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.PhotoMessage.description)
}
#endif
inline void PhotoMessage::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.PhotoMessage.description)
}
inline void PhotoMessage::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.PhotoMessage.description)
}
inline ::std::string* PhotoMessage::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.PhotoMessage.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PhotoMessage::release_description() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.PhotoMessage.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PhotoMessage::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.PhotoMessage.description)
}

// string metaData = 5;
inline void PhotoMessage::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PhotoMessage::metadata() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.PhotoMessage.metaData)
  return metadata_.GetNoArena();
}
inline void PhotoMessage::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.PhotoMessage.metaData)
}
#if LANG_CXX11
inline void PhotoMessage::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.PhotoMessage.metaData)
}
#endif
inline void PhotoMessage::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.PhotoMessage.metaData)
}
inline void PhotoMessage::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.PhotoMessage.metaData)
}
inline ::std::string* PhotoMessage::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.PhotoMessage.metaData)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PhotoMessage::release_metadata() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.PhotoMessage.metaData)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PhotoMessage::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.PhotoMessage.metaData)
}

// -------------------------------------------------------------------

// C2SMessage

// .realtime.messageservice.C2SMessage.MessageType type = 1;
inline void C2SMessage::clear_type() {
  type_ = 0;
}
inline ::realtime::messageservice::C2SMessage_MessageType C2SMessage::type() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.C2SMessage.type)
  return static_cast< ::realtime::messageservice::C2SMessage_MessageType >(type_);
}
inline void C2SMessage::set_type(::realtime::messageservice::C2SMessage_MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.C2SMessage.type)
}

// .realtime.messageservice.BaseMessage base = 2;
inline bool C2SMessage::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void C2SMessage::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) delete base_;
  base_ = NULL;
}
inline const ::realtime::messageservice::BaseMessage& C2SMessage::base() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.C2SMessage.base)
  return base_ != NULL ? *base_
                         : *::realtime::messageservice::BaseMessage::internal_default_instance();
}
inline ::realtime::messageservice::BaseMessage* C2SMessage::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::realtime::messageservice::BaseMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.C2SMessage.base)
  return base_;
}
inline ::realtime::messageservice::BaseMessage* C2SMessage::release_base() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.C2SMessage.base)
  
  ::realtime::messageservice::BaseMessage* temp = base_;
  base_ = NULL;
  return temp;
}
inline void C2SMessage::set_allocated_base(::realtime::messageservice::BaseMessage* base) {
  delete base_;
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.C2SMessage.base)
}

// int64 nonceID = 3;
inline void C2SMessage::clear_nonceid() {
  nonceid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 C2SMessage::nonceid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.C2SMessage.nonceID)
  return nonceid_;
}
inline void C2SMessage::set_nonceid(::google::protobuf::int64 value) {
  
  nonceid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.C2SMessage.nonceID)
}

// .realtime.messageservice.AuthenticateMessage authMessage = 4;
inline bool C2SMessage::has_authmessage() const {
  return messages_case() == kAuthMessage;
}
inline void C2SMessage::set_has_authmessage() {
  _oneof_case_[0] = kAuthMessage;
}
inline void C2SMessage::clear_authmessage() {
  if (has_authmessage()) {
    delete messages_.authmessage_;
    clear_has_messages();
  }
}
inline  const ::realtime::messageservice::AuthenticateMessage& C2SMessage::authmessage() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.C2SMessage.authMessage)
  return has_authmessage()
      ? *messages_.authmessage_
      : ::realtime::messageservice::AuthenticateMessage::default_instance();
}
inline ::realtime::messageservice::AuthenticateMessage* C2SMessage::mutable_authmessage() {
  if (!has_authmessage()) {
    clear_messages();
    set_has_authmessage();
    messages_.authmessage_ = new ::realtime::messageservice::AuthenticateMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.C2SMessage.authMessage)
  return messages_.authmessage_;
}
inline ::realtime::messageservice::AuthenticateMessage* C2SMessage::release_authmessage() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.C2SMessage.authMessage)
  if (has_authmessage()) {
    clear_has_messages();
    ::realtime::messageservice::AuthenticateMessage* temp = messages_.authmessage_;
    messages_.authmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void C2SMessage::set_allocated_authmessage(::realtime::messageservice::AuthenticateMessage* authmessage) {
  clear_messages();
  if (authmessage) {
    set_has_authmessage();
    messages_.authmessage_ = authmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.C2SMessage.authMessage)
}

// .realtime.messageservice.TextMessage txt = 5;
inline bool C2SMessage::has_txt() const {
  return messages_case() == kTxt;
}
inline void C2SMessage::set_has_txt() {
  _oneof_case_[0] = kTxt;
}
inline void C2SMessage::clear_txt() {
  if (has_txt()) {
    delete messages_.txt_;
    clear_has_messages();
  }
}
inline  const ::realtime::messageservice::TextMessage& C2SMessage::txt() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.C2SMessage.txt)
  return has_txt()
      ? *messages_.txt_
      : ::realtime::messageservice::TextMessage::default_instance();
}
inline ::realtime::messageservice::TextMessage* C2SMessage::mutable_txt() {
  if (!has_txt()) {
    clear_messages();
    set_has_txt();
    messages_.txt_ = new ::realtime::messageservice::TextMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.C2SMessage.txt)
  return messages_.txt_;
}
inline ::realtime::messageservice::TextMessage* C2SMessage::release_txt() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.C2SMessage.txt)
  if (has_txt()) {
    clear_has_messages();
    ::realtime::messageservice::TextMessage* temp = messages_.txt_;
    messages_.txt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void C2SMessage::set_allocated_txt(::realtime::messageservice::TextMessage* txt) {
  clear_messages();
  if (txt) {
    set_has_txt();
    messages_.txt_ = txt;
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.C2SMessage.txt)
}

// .realtime.messageservice.PhotoMessage photoMsg = 6;
inline bool C2SMessage::has_photomsg() const {
  return messages_case() == kPhotoMsg;
}
inline void C2SMessage::set_has_photomsg() {
  _oneof_case_[0] = kPhotoMsg;
}
inline void C2SMessage::clear_photomsg() {
  if (has_photomsg()) {
    delete messages_.photomsg_;
    clear_has_messages();
  }
}
inline  const ::realtime::messageservice::PhotoMessage& C2SMessage::photomsg() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.C2SMessage.photoMsg)
  return has_photomsg()
      ? *messages_.photomsg_
      : ::realtime::messageservice::PhotoMessage::default_instance();
}
inline ::realtime::messageservice::PhotoMessage* C2SMessage::mutable_photomsg() {
  if (!has_photomsg()) {
    clear_messages();
    set_has_photomsg();
    messages_.photomsg_ = new ::realtime::messageservice::PhotoMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.C2SMessage.photoMsg)
  return messages_.photomsg_;
}
inline ::realtime::messageservice::PhotoMessage* C2SMessage::release_photomsg() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.C2SMessage.photoMsg)
  if (has_photomsg()) {
    clear_has_messages();
    ::realtime::messageservice::PhotoMessage* temp = messages_.photomsg_;
    messages_.photomsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void C2SMessage::set_allocated_photomsg(::realtime::messageservice::PhotoMessage* photomsg) {
  clear_messages();
  if (photomsg) {
    set_has_photomsg();
    messages_.photomsg_ = photomsg;
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.C2SMessage.photoMsg)
}

inline bool C2SMessage::has_messages() const {
  return messages_case() != MESSAGES_NOT_SET;
}
inline void C2SMessage::clear_has_messages() {
  _oneof_case_[0] = MESSAGES_NOT_SET;
}
inline C2SMessage::MessagesCase C2SMessage::messages_case() const {
  return C2SMessage::MessagesCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// S2CMessage

// string commonMessage = 1;
inline void S2CMessage::clear_commonmessage() {
  commonmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& S2CMessage::commonmessage() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.commonMessage)
  return commonmessage_.GetNoArena();
}
inline void S2CMessage::set_commonmessage(const ::std::string& value) {
  
  commonmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:realtime.messageservice.S2CMessage.commonMessage)
}
#if LANG_CXX11
inline void S2CMessage::set_commonmessage(::std::string&& value) {
  
  commonmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:realtime.messageservice.S2CMessage.commonMessage)
}
#endif
inline void S2CMessage::set_commonmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  commonmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:realtime.messageservice.S2CMessage.commonMessage)
}
inline void S2CMessage::set_commonmessage(const char* value, size_t size) {
  
  commonmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:realtime.messageservice.S2CMessage.commonMessage)
}
inline ::std::string* S2CMessage::mutable_commonmessage() {
  
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.S2CMessage.commonMessage)
  return commonmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* S2CMessage::release_commonmessage() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.S2CMessage.commonMessage)
  
  return commonmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void S2CMessage::set_allocated_commonmessage(::std::string* commonmessage) {
  if (commonmessage != NULL) {
    
  } else {
    
  }
  commonmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commonmessage);
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.S2CMessage.commonMessage)
}

// .realtime.messageservice.BaseMessage base = 2;
inline bool S2CMessage::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void S2CMessage::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) delete base_;
  base_ = NULL;
}
inline const ::realtime::messageservice::BaseMessage& S2CMessage::base() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.base)
  return base_ != NULL ? *base_
                         : *::realtime::messageservice::BaseMessage::internal_default_instance();
}
inline ::realtime::messageservice::BaseMessage* S2CMessage::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::realtime::messageservice::BaseMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.S2CMessage.base)
  return base_;
}
inline ::realtime::messageservice::BaseMessage* S2CMessage::release_base() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.S2CMessage.base)
  
  ::realtime::messageservice::BaseMessage* temp = base_;
  base_ = NULL;
  return temp;
}
inline void S2CMessage::set_allocated_base(::realtime::messageservice::BaseMessage* base) {
  delete base_;
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.S2CMessage.base)
}

// uint64 msgID = 3;
inline void S2CMessage::clear_msgid() {
  msgid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 S2CMessage::msgid() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.msgID)
  return msgid_;
}
inline void S2CMessage::set_msgid(::google::protobuf::uint64 value) {
  
  msgid_ = value;
  // @@protoc_insertion_point(field_set:realtime.messageservice.S2CMessage.msgID)
}

// .realtime.messageservice.AuthenticateReply authReply = 5;
inline bool S2CMessage::has_authreply() const {
  return Messages_case() == kAuthReply;
}
inline void S2CMessage::set_has_authreply() {
  _oneof_case_[0] = kAuthReply;
}
inline void S2CMessage::clear_authreply() {
  if (has_authreply()) {
    delete Messages_.authreply_;
    clear_has_Messages();
  }
}
inline  const ::realtime::messageservice::AuthenticateReply& S2CMessage::authreply() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.authReply)
  return has_authreply()
      ? *Messages_.authreply_
      : ::realtime::messageservice::AuthenticateReply::default_instance();
}
inline ::realtime::messageservice::AuthenticateReply* S2CMessage::mutable_authreply() {
  if (!has_authreply()) {
    clear_Messages();
    set_has_authreply();
    Messages_.authreply_ = new ::realtime::messageservice::AuthenticateReply;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.S2CMessage.authReply)
  return Messages_.authreply_;
}
inline ::realtime::messageservice::AuthenticateReply* S2CMessage::release_authreply() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.S2CMessage.authReply)
  if (has_authreply()) {
    clear_has_Messages();
    ::realtime::messageservice::AuthenticateReply* temp = Messages_.authreply_;
    Messages_.authreply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void S2CMessage::set_allocated_authreply(::realtime::messageservice::AuthenticateReply* authreply) {
  clear_Messages();
  if (authreply) {
    set_has_authreply();
    Messages_.authreply_ = authreply;
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.S2CMessage.authReply)
}

// .realtime.messageservice.TextMessage txt = 6;
inline bool S2CMessage::has_txt() const {
  return Messages_case() == kTxt;
}
inline void S2CMessage::set_has_txt() {
  _oneof_case_[0] = kTxt;
}
inline void S2CMessage::clear_txt() {
  if (has_txt()) {
    delete Messages_.txt_;
    clear_has_Messages();
  }
}
inline  const ::realtime::messageservice::TextMessage& S2CMessage::txt() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.txt)
  return has_txt()
      ? *Messages_.txt_
      : ::realtime::messageservice::TextMessage::default_instance();
}
inline ::realtime::messageservice::TextMessage* S2CMessage::mutable_txt() {
  if (!has_txt()) {
    clear_Messages();
    set_has_txt();
    Messages_.txt_ = new ::realtime::messageservice::TextMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.S2CMessage.txt)
  return Messages_.txt_;
}
inline ::realtime::messageservice::TextMessage* S2CMessage::release_txt() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.S2CMessage.txt)
  if (has_txt()) {
    clear_has_Messages();
    ::realtime::messageservice::TextMessage* temp = Messages_.txt_;
    Messages_.txt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void S2CMessage::set_allocated_txt(::realtime::messageservice::TextMessage* txt) {
  clear_Messages();
  if (txt) {
    set_has_txt();
    Messages_.txt_ = txt;
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.S2CMessage.txt)
}

// .realtime.messageservice.PhotoMessage photoMsg = 7;
inline bool S2CMessage::has_photomsg() const {
  return Messages_case() == kPhotoMsg;
}
inline void S2CMessage::set_has_photomsg() {
  _oneof_case_[0] = kPhotoMsg;
}
inline void S2CMessage::clear_photomsg() {
  if (has_photomsg()) {
    delete Messages_.photomsg_;
    clear_has_Messages();
  }
}
inline  const ::realtime::messageservice::PhotoMessage& S2CMessage::photomsg() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.photoMsg)
  return has_photomsg()
      ? *Messages_.photomsg_
      : ::realtime::messageservice::PhotoMessage::default_instance();
}
inline ::realtime::messageservice::PhotoMessage* S2CMessage::mutable_photomsg() {
  if (!has_photomsg()) {
    clear_Messages();
    set_has_photomsg();
    Messages_.photomsg_ = new ::realtime::messageservice::PhotoMessage;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.S2CMessage.photoMsg)
  return Messages_.photomsg_;
}
inline ::realtime::messageservice::PhotoMessage* S2CMessage::release_photomsg() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.S2CMessage.photoMsg)
  if (has_photomsg()) {
    clear_has_Messages();
    ::realtime::messageservice::PhotoMessage* temp = Messages_.photomsg_;
    Messages_.photomsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void S2CMessage::set_allocated_photomsg(::realtime::messageservice::PhotoMessage* photomsg) {
  clear_Messages();
  if (photomsg) {
    set_has_photomsg();
    Messages_.photomsg_ = photomsg;
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.S2CMessage.photoMsg)
}

// .google.protobuf.Any anything = 20;
inline bool S2CMessage::has_anything() const {
  return this != internal_default_instance() && anything_ != NULL;
}
inline void S2CMessage::clear_anything() {
  if (GetArenaNoVirtual() == NULL && anything_ != NULL) delete anything_;
  anything_ = NULL;
}
inline const ::google::protobuf::Any& S2CMessage::anything() const {
  // @@protoc_insertion_point(field_get:realtime.messageservice.S2CMessage.anything)
  return anything_ != NULL ? *anything_
                         : *::google::protobuf::Any::internal_default_instance();
}
inline ::google::protobuf::Any* S2CMessage::mutable_anything() {
  
  if (anything_ == NULL) {
    anything_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:realtime.messageservice.S2CMessage.anything)
  return anything_;
}
inline ::google::protobuf::Any* S2CMessage::release_anything() {
  // @@protoc_insertion_point(field_release:realtime.messageservice.S2CMessage.anything)
  
  ::google::protobuf::Any* temp = anything_;
  anything_ = NULL;
  return temp;
}
inline void S2CMessage::set_allocated_anything(::google::protobuf::Any* anything) {
  delete anything_;
  anything_ = anything;
  if (anything) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:realtime.messageservice.S2CMessage.anything)
}

inline bool S2CMessage::has_Messages() const {
  return Messages_case() != MESSAGES_NOT_SET;
}
inline void S2CMessage::clear_has_Messages() {
  _oneof_case_[0] = MESSAGES_NOT_SET;
}
inline S2CMessage::MessagesCase S2CMessage::Messages_case() const {
  return S2CMessage::MessagesCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace messageservice
}  // namespace realtime

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::realtime::messageservice::LoginRequest_LoginType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::realtime::messageservice::LoginRequest_LoginType>() {
  return ::realtime::messageservice::LoginRequest_LoginType_descriptor();
}
template <> struct is_proto_enum< ::realtime::messageservice::LoginReply_LoginCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::realtime::messageservice::LoginReply_LoginCode>() {
  return ::realtime::messageservice::LoginReply_LoginCode_descriptor();
}
template <> struct is_proto_enum< ::realtime::messageservice::C2SMessage_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::realtime::messageservice::C2SMessage_MessageType>() {
  return ::realtime::messageservice::C2SMessage_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messageservice_2eproto__INCLUDED
